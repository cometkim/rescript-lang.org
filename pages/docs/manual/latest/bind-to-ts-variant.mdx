---
title: "Bind variants to TS"
description: "Interop with ReScript variants in TypeScript"
canonical: "/docs/manual/latest/bind-to-ts-variant"
---

# Bind ReScript variants to TS

Ordinary variants (with capitalized cases, e.g. `| A | B(int)`) and polymorphic variants (with a backtick, e.g. `` | `A | `B(int) ``) are represented in the same way, so there's no difference from the point of view of JavaScript. Polymorphic variants don't have to be capitalized.

Variants can have an _unboxed_, or a _boxed_ representation. The unboxed representation is used when there is at most one case with a payload, and that payload has object type; otherwise, a boxed representation is used. Object types are arrays, objects, records and tuples.

Variants without payloads are essentially sequences of identifiers.
E.g. type `@genType type days = Monday | Tuesday`.
The corresponding JS representation is `"Monday"`, `"Tuesday"`.
Similarly, polymorphic variant type `@genType type days = [#Monday | #Tuesday]` has the same JS representation.

When at most one variant case has a payload, and if the payload is of object type, e.g.
`Unnamed | Named({. "name": string, "surname": string})`
then the representation is unboxed: JS values are e.g. `"Unnamed"` and
`{name: "hello", surname: "world"}`. Similarly for polymorphic variants.
Note that this unboxed representation does not use the label `"Named"` of the variant case with payload, because that value is distinguished from the other payload-less cases by its type: an object.

If there is more than one case with payload, or if the single payload has not type object, a boxed representation is used. The boxed representation has shape `{tag: "someTag", value: someValue}`.
For example, type `| A | B(int) | C(string)` has values such as `"A"` and
`{tag: "B", value: 42}` and `{tag: "C", value: "hello"}`.
Polymorhphic variants are treated similarly. Notice that payloads for polymorphic variants are always unary: `` `Pair(int,int) `` has a single payload of type `(int,int)`. Instead, ordinary variants distinguish between unary `Pair((int,int))` and binary `Pair(int,int)` payloads. All those cases are represented in JS as `{tag: "Pair", value: [3, 4]}`, and the conversion functions take care of the different ReScript representations.

The `@genType.as` annotation can be used to modify the name emitted for a variant case on the JS side. So e.g. `| @genType.as("Arenamed") A` exports ReScript value `A` to JS value `"Arenamed"`.
Boolean/integer/float constants can be expressed as `| @genType.as(true) True` and `| @genType.as(20) Twenty` and `| @genType.as(0.5) Half`. Similarly for polymorphic variants.
The `@genType.as` annotation can also be used on variants with payloads to determine what appears in `{ tag: ... }`.

For more examples, see [Variants.res](https://github.com/reason-association/genType/tree/master/examples/typescript-react-example/src/Variants.res) and [VariantsWithPayload.res](https://github.com/reason-association/genType/tree/master/examples/typescript-react-example/src/VariantsWithPayload.res).

**NOTE:** When exporting/importing values that have polymorphic variant type, you have to use type annotations, and cannot rely on type inference. So instead of `` let monday = `Monday ``, use `` let monday : days = `Monday ``. The former does not work, as the type checker infers a type without annotations.
